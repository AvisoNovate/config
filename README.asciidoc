= Config - Smart and flexible system configuration

image:http://clojars.org/io.aviso/config/latest-version.svg[Clojars Project, link="http://clojars.org/io.aviso/config"]

Config is a very small library used to handle configuration of a server; it works
quite well with a system defined in terms of
link:https://github.com/stuartsierra/component[Stuart Sierra's component library].

link:https://medium.com/@hlship/microservices-configuration-and-clojure-4f6807ef9bea[This posting] provides
a lot of detail on the requirements and capabilities of config.

link:http://howardlewisship.com/io.aviso/config/[API Documentation]

== Overview

Config reads a series of files, primarily from the classpath.
The files contain contain configuration data, in either
link:http://yaml.org/[YAML] or
link:https://github.com/edn-format/edn[EDN] format.

The files are read in a specific order, based on a set of _profiles_.
The name of the file to read is based on the profile.

The contents of all the files are converted to Clojure maps (with keyword keys) and are
deep-merged together.

Meanwhile, a set of
link:https://github.com/Prismatic/schema[schemas] are merged together, and used to validate and coerce
the data read from the individual configuration files.

The intent of profiles is that there is an approximate mapping between components and profiles.
Each component will provide a schema (for validation and coercion) and profiles are used to ensure
the correct configuration data is read.

But what about the
link:http://12factor.net/config[12 Factor App]'s guideline to store configuration only as environment
variables?
This is embraced by config, because the files may contain environment variable references that are expanded
at runtime, before parsing of the file content.

At link:http://www.aviso.io/[Aviso], we use these features in a number of ways.
For example, for quick testing we combine a number of microservices (each of which
has its own configuration profile and schema) together into a single system, and specify a large set of profiles.
Meanwhile, in production (on AWS) we can build a smaller system with a single microservice, and single profile.
We can also provide an additional configuration file that enables configuration overrides based on environment variables
set by CloudFormation.

When used with component, each component will have a keyword that will be used as a top-level key
in the merged configuration, and as a configuration profile.

== Implementing Components

For example, you might define a web service as:

[source,clojure]
----
(defrecord WebService [configuration request-handler jetty-instance]

  component/Lifecycle

  (start [this]
    (assoc :jetty-instance (jetty/run-jetty
                              request-handler
                              {:port (get-in configuration [:web-service :port])
                               :join? false})))

  (stop [this]
    (.stop jetty-instance)
    this))

(s/defschema WebServiceConfig
  {:web-service {:port s/Int}})

(defn new-web-service
  []
  (-> (map->WebService {})
      (component/using [:configuration :request-handler])
      (config/with-config-schema WebServiceConfig)))
----

Notice that the component receives the *entire* configuration in its
:configuration key (as a dependency). It can then extract the value(s)
it needs.

== Providing Configuration Files

Without configuration files, your application will not start up; you will see
errors about invalid schemas, because there is (in this example)
no :web-service top-level key, and no :port key below that.

Configuration files are on the class path; this means directly underneath
the `resources` folder in a typical project.

For the :web-service component, you would
provide a default configuration file, `web-service-configuration.yaml`:

[source,clojure]
----
web-service:
  port: 8080
----

== Starting the System

And finally, build and start a system from all this:

[source,clojure]
----
(-> (component/system-map
      :web-service (new-web-service)
      :request-handler (new-request-handler))
    (config/extend-system-map {:profiles [:web-service]})
    component/start-system)
----

The `extend-system-map` function reads the configuration files and associates
a new key, :configuration, into the system map, containing all the configuration
data.
This configuration data is then available to the components, as injected
dependencies (as outlined in the code sample above).

== Overrides

But what if you want to override part of the :web-service configuration ...
for example, to specify a different port?

This can be accomplished in a number of ways:

- By supplying a `configuration.yaml` file (this corresponds to the nil profile,
  which is loaded last).
- By supplying a `web-service-local-configuration.yaml` file (because the :local
  variant is loaded *after* the default variant).
- By providing direct overrides to the configuration using the :overrides option
  key.
- By supplying an `override-configuration.yaml` file, and setting the
  :profile option key to [:web-service :override].
- By specifying additional files (on the file system, not the classpath)
  to load using the :additional-files option key.

Config is easily extensible to override how configuration files are named, and to support new formats
of configuration files (by adding new extensions and parsers).

== Focused Configuration

Starting in 0.1.9, it is possible to receive configuration specific to the
component.

[source,clojure]
----
(defrecord WebService [port request-handler jetty-instance]

  Configurable

  (configure [this configuration]
    (merge this configuration))

  component/Lifecycle

  (start [this]
    (assoc :jetty-instance (jetty/run-jetty
                              request-handler
                              {:port port
                               :join? false})))

  (stop [this]
    (.stop jetty-instance)
    this))

(s/defschema WebServiceConfig
  {:port s/Int})

(defn new-web-service
  []
  (-> (map->WebService {})
      (component/using [:request-handler])
      (config/with-config-schema :web-service WebServiceConfig)))
----

There's a number of changes:

- Instead of a dependency on the configuration component, there is an additional
  field for the port provided in the configuration.
- WebServiceConfig is *just* the configuration of the :web-service component
- `with-config-schema` provides an additional argument, the top-level key
- The `configure` method gets just the configuration for the :web-service
  component; the map with the :port key.
- The `start` method is invoked *after* the `configure` method, so the port
  field is initialized.

The startup code is slightly changed as well:

[source,clojure]
----
(-> (component/system-map
      :web-service (new-web-service)
      :request-handler (new-request-handler))
    (config/extend-system-map {:profiles [:web-service]})
    configure-components
    component/start-system)
----

The call to `configure-components` is the difference.

If a component does not extend the Configurable protocol, it will
instead have a :component key assoc'ed with the component's individual
configuration map.

It is necessary to invoke the three-argument version of `with-config-schema`
to trigger this; otherwise `configure-components` does not know what key
in the merged configuration map to extract for the component.

== License

Config is available under the terms of the Apache Software License 2.0.
