= Config - Smart and flexible system configuration

image:http://clojars.org/io.aviso/config/latest-version.svg[Clojars Project, link="http://clojars.org/io.aviso/config"]

Config is a very small library used to handle configuration of a server; it works
quite well with a system defined in terms of
link:https://github.com/stuartsierra/component[Stuart Sierra's component library].

link:https://medium.com/@hlship/microservices-configuration-and-clojure-4f6807ef9bea[This posting] provides
a lot of detail on the requirements and capabilities of config.

link:http://avisonovate.github.io/docs/config/[API Documentation]

== Overview

Config reads a series of files, primarily from the classpath.
The files contain contain configuration data, in either
link:http://yaml.org/[YAML] or
link:https://github.com/edn-format/edn[EDN] format.

The files are read in a specific order, based on a set of _profiles_.
The name of the file to read is based on the profile, the variant (described shortly), and the
extension (YAML or EDN).

The contents of all the configuration files are converted to Clojure maps (with keyword keys) and are
deep-merged together.

Meanwhile, a set of
link:https://github.com/Prismatic/schema[schemas] are merged together, and used to validate and coerce
the data read from the individual configuration files.

The intent of profiles is that there is an approximate mapping between components and profiles.
Each component will provide a schema (for validation and coercion) and profiles are used to ensure
the correct configuration data is read.

But what about the
link:http://12factor.net/config[12 Factor App]'s guideline to store configuration only as environment
variables?
This is embraced by config, because the files may contain environment variable references that are expanded
at runtime, before parsing of the file content.

At link:http://www.aviso.io/[Aviso], we use these features in a number of ways.
For example, for quick testing we combine a number of microservices (each of which
has its own configuration profile and schema) together into a single system, and specify a large set of profiles.
Meanwhile, in production (on AWS) we can build a smaller system with a single microservice, and single profile.
We can also provide an additional configuration file that enables configuration overrides based on environment variables
set by CloudFormation.

When used with component, each component will have a keyword that will be used as a top-level key
in the merged configuration, and as a configuration profile.

== Implementing Components

For example, you might define a web service as:

[source,clojure]
----
(defrecord WebService [configuration request-handler jetty-instance]

  component/Lifecycle

  (start [this]
    (assoc :jetty-instance (jetty/run-jetty
                              request-handler
                              {:port (get-in configuration [:web-service :port])
                               :join? false})))

  (stop [this]
    (.stop jetty-instance)
    this))

(s/defschema WebServiceConfig
  {:web-service {:port s/Int}})

(defn web-service
  []
  (-> (map->WebService {})
      (component/using [:configuration :request-handler])
      (config/with-config-schema WebServiceConfig)))
----

This component has a dependency on the :configuration component; in reality
the configuration component is just the final map of configuration data (read from all files,
merged together, validated and coerced).

It has dependency on the :request-handler component, and a local slot for the
Jetty server instance this component manages.

Notice that the component receives the *entire* system's configuration in its
:configuration key (as a dependency). It can then extract the values it needs.

This is not ideal -- a better option was subsequently added and is
link:#focused-configuration[described below].
But first, we need to provide the configuration data this service needs.

== Providing Configuration Files

Without configuration files, your application will not start up; you will see
errors about invalid schemas, because there is (in this example)
no :web-service top-level key, and no :port key below that.

Configuration files are on the class path, within a `conf` package; this means inside
the `resources/conf` folder in a typical project.

For the :web-service component, you would
provide a default configuration file, `web-service.yaml`:

[source,clojure]
----
web-service:
  port: 8080
----

== Starting the System

And finally, build and start a system from all this:

[source,clojure]
----
(-> (component/system-map
      :web-service (web-service)
      :request-handler (request-handler))
    (config/extend-system-map {:profiles [:web-service]})
    component/start-system)
----

The `extend-system-map` function reads the configuration files and associates
a new key, :configuration, into the system map, containing all the configuration
data.

This configuration data is then available to the components, as injected
dependencies (as outlined in the code sample above).

Notice the specification of the :web-service profile; this controls exactly which
configuration files will be loaded, merged, and validated.

The :web-service key is being used in three ways here:

* As the component key in the system map
* As the name of the profile for the component, identifying the configuration file(s) for the compoment
* As the key within the system configuration containing the component's specific configuration

== Overrides

But what if you want to override part of the :web-service configuration ...
for example, to specify a different port?

This can be accomplished in a number of ways.

First off all, it is possible to provide an explicit map of overrides
when constructing the configuration map:

[source,clojure]
----
   (config/extend-system-map {:profiles [:web-service]
                              :overrides {:web-service {:port 9999}}})
----

However, that option is generally intended for special cases, such as overrides
during testing.

Most other approaches involve controlling which files are loaded to form the system configuration.

So if you wish to have some overrides, you could provide a configuration file named `overrides.yaml`
and ensure that is loaded after the :web-service profile:

[source,clojure]
----
   (config/extend-system-map {:profiles  [:web-service :overrides]
                              :overrides {:web-service {:port 9999}}})
----

Another option is to support an additional _variant_ for testing.

For each profile, config searches for any variant.

In this case, the file name would be `web-service-overrides.yaml`.
`web-service` comes from the profil,e and `overrides` from the variant.

[source,clojure]
----
   (config/extend-system-map {:profiles [:web-service]
                              :variants [:overrides]})
----

The nil variant (`web-service.yaml`) is always loaded first,
the provided variants (when they exist) overlay the nil variant.

You could also explicitly load one or more file-system files:

[source,clojure]
----
   (config/extend-system-map {:profiles         [:web-service]
                              :additional-files ["overrides/tests.yaml"]})
----

And finally, the :args option is intended to consume command line arguments:

[source,clojure]
----
   (config/extend-system-map {:profiles [:web-service]
                              :args     ["--load" "overrides/tests.yaml"]})
----

or even:

[source,clojure]
----
   (config/extend-system-map {:profiles [:web-service]
                              :args     ["web-service/port=9999"]})
----


Beyond this, it is possible to override how config expects files to be named, and to support
new formats for configuration files.

== Focused Configuration

Starting in 0.1.9, it is possible to receive configuration specific to the
component.

[source,clojure]
----
(defrecord WebService [port request-handler jetty-instance]

  config/Configurable

  (configure [this configuration]
    (merge this configuration))

  component/Lifecycle

  (start [this]
    (assoc :jetty-instance (jetty/run-jetty
                              request-handler
                              {:port port
                               :join? false})))

  (stop [this]
    (.stop jetty-instance)
    this))

(s/defschema WebServiceConfig
  {:port s/Int})

(defn web-service
  []
  (-> (map->WebService {})
      (component/using [:request-handler])
      (config/with-config-schema :web-service WebServiceConfig)))
----

There's a number of changes:

- Instead of a dependency on the configuration component, there is an additional
  field for the port provided in the configuration.
- WebServiceConfig is *just* the configuration of the :web-service component
- `with-config-schema` provides an additional argument, the top-level key
- The `configure` method gets just the configuration for the :web-service
  component; the map with the :port key (as defined by the WebServiceConfig schema).
- The `start` method is invoked *after* the `configure` method, so the port
  field is initialized.

Again, it typically makes sense for the component key, the profile name, and the configuration key
for the component to all match; in this case, the value :web-service.

The startup code is slightly changed as well:

[source,clojure]
----
(-> (component/system-map
      :web-service (web-service)
      :request-handler (request-handler))
    (config/extend-system-map {:profiles [:web-service]})
    config/configure-components
    component/start-system)
----

The call to `configure-components` is the difference.

If a component does not extend the Configurable protocol, it will
instead have a :component key assoc'ed with the component's individual
configuration map (not the complete system configuration).

It is necessary to invoke the three-argument version of `with-config-schema`
to trigger this behavior; otherwise `configure-components` does not know what key
in the merged configuration map to extract for the component.

== License

Config is available under the terms of the Apache Software License 2.0.
